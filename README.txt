1. Individual work2. Adopted the structure from Hangman code, I used 3 classes to run the Evil Hangman game: EvilHangman.java, EvilSolution.java, and EvilHangmanRunner.java. I added some code to check if methods are well-scoped. For example, I checked if worklist is empty, checked if user input a letter instead of number or other stuff, and made sure that the least situation is user guessed 26 letters. The program minimizes dependencies on external components: File I/O is abstracted during testing by allowing a mock dictionary (List<String>) to be passed to the constructor. Scanner is only used within the start method, isolating user I/O to a single location.3. First, EvilHangman read a dictionary file and initialized the game with all words of the same length. Then, the code initialize the variables, including previousGuesses, incorrectGuesses, and solution. Group words into “families” based on where the guessed letter appears in each word. Select the largest family(contains the most words) and return the family pattern. Update previouGuesses and partition the wordlist. Updates the solution or adds the guess to incorrectGuesses if it’s wrong. If user guessed all the letters in the words, user win. If not, continuously prompts for guesses until all 26 letters have benn guessed.